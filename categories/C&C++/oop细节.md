# oop细节
* 基类应该定义虚析构函数  virtual ~Quote() = default; // 虚析构函数 基类应该定义的  
    析构函数必须是虚函数,因为在delete p的时候,p是指针是动态绑定的需要根据当前绑定的对象执行相应的析构函数,所以析构函数需要被继承重写,在delete的时候会想基类反向调用,一层一层执行相应的析构函数。
* 如果基类定义了静态成员，则整个继承体系只存在唯一实例。  
* 可以将基类的指针(包括智能指针)或引用绑定到派生类对象，实现**动态绑定**。  
* **回避虚函数机制**：使用作用域强行执行特定版本baseP->Quote::net_price(42);  
* 派生类的构造函数只能对直接基类初始化而简介基类不行，所以是层层初始化的关系。  
* 派生访问说明符(基类前的public private)的目的是控制派生类用户(包括派生类的派生类)对于基类成员的访问权限，而不是此派生类对基类的访问权限(是由基类成员的访问说明符控制的)。  
* **基类接口设计**: 基类的接口成员可以分为以下三种。外部使用的声明为public，供派生类访问的声明为protected，自己几自己的有元使用的声明为private。  
* 使用using可以改变个别成员的可访问性
* 在派生类中定义拷贝构造函数、复赋值运算符的过程中一定要显示的调用基类的复制构造函数和赋值运算符函数，否则对应的基类成员将执行默认初始化。  
* 在C++11中，派生类能够重用基类的构造函数，通过在派生类中**using *base*::*base*** 声明。等价为 ***derived(parms) : base(args){ }***
  