---
layout: "post"
title: "C++ 面试知识点"
date: "2019-10-17 19:29"
categories: "Interview"
---
## static
**作用**  
* 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
* 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
* 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
* 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员(不知道是哪个对象的成员)。   

## inline函数
**编辑器对inline函数的处理步骤** (弱)
*  将 inline 函数体复制到 inline 函数调用点处；
*  为所用 inline 函数中的局部变量分配内存空间；
*  将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
* 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

**缺点**
* inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
* 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

## 虚函数可以是内联函数吗?

 *   虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
 *  内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
 *   inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

## volatile
*  volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
* volatile并不能支持很多并发编程的特性，因为多线程多核中右各自不同的cache，优先还是在cahce中去取,并不能达到指定的效果。

## extern "C"

*    被 extern 限定的函数或变量是 extern 类型的。
*    被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和链接的。
*  extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

## Ｃ实现Ｃ++类
面向对象特性：封装、继承、多态。

*    封装：使用函数指针把属性与方法封装到结构体中
*   继承：结构体嵌套
*   多态：父类与子类方法的函数指针不同(通过static function 改变原函数指针实现多态)

## using 指示与 using声明
using指示是using namespace __ 在命名空间中所有名字都可见。using 声明是std::cout 或using std::cout。**尽量少使用using指示 多使用using 声明**。

## decltype
* 对于函数返回的是函数返回类型，而对于左值是引用类型，要返回值类型使用remove_reference。
```
// 尾置返回允许我们在参数列表之后声明返回类型
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的引用
}
// 为了使用模板参数成员，必须用 typename
template <typename It>
auto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的拷贝
}
```

## 右值引用
右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

## 引用折叠规则
* 所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）
* 所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）

## 虚析构函数
虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。
##虚函数和纯虚函数
* 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
* 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
* 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
* 虚基类是虚继承中的基类，具体见下文虚继承。
## 虚函数表和虚函数指针
*   虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
*   虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](https://github.com/huihut/interview#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

## 虚继承
* 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

* 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

* 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

## 抽象类、接口类、聚合类
* 抽象类：含有纯虚函数的类
* 接口类：仅含有纯虚函数的抽象类
* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
所有成员都是 public
没有定义任何构造函数
没有类内初始化
没有基类，也没有 virtual 函数

### 如何定义一个只能在堆上（栈上）生成对象的类？

> [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

#### [](https://github.com/huihut/interview#%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A)只能在堆上

方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

#### [](https://github.com/huihut/interview#%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A)只能在栈上

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

### [](https://github.com/huihut/interview#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88)
