# 多线程信号问题
在linux下，每个进程都有自己的signal mask，这个信号掩码指定哪个信号被阻塞，哪个不会被阻塞，通常用调用sigmask来处理。同时每个进程还有自己的signal action，这个行为集合指定了信号该如何处理，通常调用sigaction来处理。  
  
  
而在多线程中，信号传递与进程有不同之处。  
 * 如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。
 * 如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。
 * 如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，然后调用它来处理。(一般从主线程找起)，注意只有一个线程能收到。　　
 
 每个线程都有自己的信号掩码，所以线程共享进程的信号处理函数。所以我们并不能为每一个线程指定自己的信号处理函数。且子线程的信号掩码会从父进程中继承。　　
 
 ## 异步信号统一处理
 为了防止逻辑错误和考虑信号在多线程特性，应该定义一个专门的信号处理线程。  
 分为两步：  
 1. 主线程在创建其他线程前用pthread_sigmask设置好信号掩码（会被其他线程继承）。
 2. 在某个线程调用sigwait(const sigset_t* set, int *sig)等待信号并处理。set是第一步中创建的信号掩码。
 这样信号到达后只会被我们指定的信号处理线程接受并处理，其他的线程正常工作。